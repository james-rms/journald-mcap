#include <sstream>
#include <string_view>

#include <systemd/sd-id128.h>
#include <systemd/sd-journal.h>

#define MCAP_IMPLEMENTATION
#include "vendor/mcap/writer.hpp"

#include "cmdline.hpp"
#include "journal.hpp"

const char *VERSION = "0.1.0";

const char *DOC = R"(
Utility for exporting journald logs to MCAP

Usage:
  journal2mcap [-o outfile.mcap] [--start <time>] [--end <time>] [--watch]

Flags:
  -o  --output    output filename (default is ./out.mcap)
  -s  --start     only export log entries starting from this unix timestamp. "now" can be provided to indicate the current time.
  -e  --end       only export log entries up until this unix timestamp.
  -w  --watch     if set, waits and continues capturing logs until SIGINT is received.
  -h  --help      prints this help message and exits.
  --version       prints a version string and exits.

Examples:

Exports logs since boot until now:
  journal2mcap

Exports logs since boot and continues logging until Ctrl-C:
  journal2mcap --watch

Exports logs starting from now and continues logging until Ctrl-C:
  journal2mcap --start now --watch

Exports logs between from Jan 1 2023 and Feb 1 2023
  journal2mcap --start $(date -d 2023-01-01 +%s) --end $(date -d 2023-02-01 +%s)

Exports logs between from midnight Jan 1 2023 until shutdown.
  journal2mcap --start $(date -d 2023-01-01 +%s)

Exports logs from the boot before midnight Mar 1 2023 until midnight Mar 1 2023.
  journal2mcap --end $(date -d 2023-03-01 +%s)
)";

static const char *SCHEMA_TEXT = R"({
  "title": "foxglove.Log",
  "description": "A log message",
  "$comment": "Generated by https://github.com/foxglove/schemas",
  "type": "object",
  "properties": {
    "timestamp": {
      "type": "object",
      "title": "time",
      "properties": {
        "sec": {
          "type": "integer",
          "minimum": 0
        },
        "nsec": {
          "type": "integer",
          "minimum": 0,
          "maximum": 999999999
        }
      },
      "description": "Timestamp of log message"
    },
    "level": {
      "title": "foxglove.LogLevel",
      "description": "Log level",
      "oneOf": [
        {
          "title": "UNKNOWN",
          "const": 0
        },
        {
          "title": "DEBUG",
          "const": 1
        },
        {
          "title": "INFO",
          "const": 2
        },
        {
          "title": "WARNING",
          "const": 3
        },
        {
          "title": "ERROR",
          "const": 4
        },
        {
          "title": "FATAL",
          "const": 5
        }
      ]
    },
    "message": {
      "type": "string",
      "description": "Log message"
    },
    "name": {
      "type": "string",
      "description": "Process or node name"
    },
    "file": {
      "type": "string",
      "description": "Filename"
    },
    "line": {
      "type": "integer",
      "minimum": 0,
      "description": "Line number in the file"
    }
  }
})";

std::string get_topic(Transport transport) {
  std::stringstream ss;
  ss << "/journald/";
  ss << name_for_transport(transport);
  return ss.str();
}

int main(int argc, const char **argv) {
  sd_journal *j;
  mcap::McapWriter writer;
  mcap::Message message;
  mcap::Channel channel;
  Options options;
  if (int err = parse_options(argc, argv, &options); err != 0) {
    return err;
  }
  if (options.help) {
    printf("%s\n", DOC);
    return 0;
  }
  if (options.version) {
    printf("%s\n", VERSION);
    return 0;
  }

  {
    sd_id128_t boot_id;
    int err = sd_id128_get_boot(&boot_id);
    if (err != 0) {
      perror("failed to get boot ID");
      return err;
    }
    err = sd_journal_open(&j, SD_JOURNAL_LOCAL_ONLY);
    if (err != 0) {
      perror("failed to open journal");
      return err;
    }
    char boot_id_match_str[8 + 1 + 32 + 1] = {0};
    snprintf(boot_id_match_str, sizeof(boot_id_match_str),
             "_BOOT_ID=" SD_ID128_FORMAT_STR, SD_ID128_FORMAT_VAL(boot_id));
    err = sd_journal_add_match(j, boot_id_match_str, 0);
    if (err != 0) {
      perror("failed to add boot ID match");
      return err;
    }
    err = sd_journal_seek_head(j);
    if (err != 0) {
      perror("failed to seek to beginning");
      return err;
    }
  }
  {
    auto writerOptions = mcap::McapWriterOptions("");
    const auto res = writer.open(options.output_filename, writerOptions);
    if (!res.ok()) {
      fprintf(stderr, "open failed: %s\n", res.message.c_str());
      return 1;
    }
  }
  // write schema
  mcap::SchemaId schema_id;
  {
    mcap::Schema schema("foxglove.Log", "jsonschema", SCHEMA_TEXT);
    writer.addSchema(schema);
    schema_id = schema.id;
  }

  std::vector<mcap::ChannelId> transport_channel_ids(_TRANSPORT_COUNT, 0);
  std::vector<uint32_t> sequence_counts(_TRANSPORT_COUNT, 0);

  for (size_t i = 0; i < _TRANSPORT_COUNT; ++i) {
    mcap::Channel channel(get_topic((Transport)(i)), "json", schema_id);
    writer.addChannel(channel);
    transport_channel_ids[i] = channel.id;
  }

  while (sd_journal_next(j) > 0) {
    uint64_t ts = 0;
    int err = get_ts(j, &ts);
    if (err != 0) {
      perror("failed to read entry timestamp");
      return err;
    }
    message.logTime = ts;
    message.publishTime = ts;
    Transport transport = get_transport(j);
    message.sequence = sequence_counts[transport];
    sequence_counts[transport]++;
    message.channelId = transport_channel_ids[transport];
    std::string json = serialize_json(j, ts);
    message.data = (const std::byte *)(json.c_str());
    message.dataSize = json.size();
    auto res = writer.write(message);
    if (!res.ok()) {
      fprintf(stderr, "failed to write message: %s\n", res.message.c_str());
      writer.close();
      return 1;
    }
  }
  writer.close();
  sd_journal_close(j);
  return 0;
}
