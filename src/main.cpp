#include <chrono>
#include <signal.h>
#include <sstream>
#include <string_view>

#include <systemd/sd-journal.h>

#define MCAP_IMPLEMENTATION
#include "vendor/mcap/writer.hpp"

#include "cmdline.hpp"
#include "journal.hpp"

const char *VERSION = "0.1.0";

const char *DOC = R"(
Utility for exporting journald logs to MCAP

Usage:
  journal2mcap [--output <filename>] [--start <arg>] [--end <arg>] [--verbose] [--help] [--version]

Flags:
  -o  --output
    Output filename (default is 'out.mcap')
  -s  --start <timestamp> | now | boot
    Specify a start point for log entries (default is 'boot')
    'boot' exports entries logged from the previous boot until the endpoint specified by --end.
    'now' exports entries logged after program start.
    <timestamp> exports entries logged after this unix timestamp.
  -e  --end   <timestamp> | now | shutdown | wait
    Specify an endpoint for log entries (default is 'now')
    'now' exports entries logged before program start
    'shutdown' exports entries from the endpoint specified by --start until the next shutdown.
    'wait' continues exporting entries logged after program start until interrupted.
    <timestamp> exports entries logged before this unix timestamp.
  -v  --verbose
    Prints info about what entries are captured while running.
  -h  --help
    Prints this help message and exits.
  --version
    prints a version string and exits.

Examples:

Exports logs since boot until now:
  journal2mcap

Exports logs since boot and continues logging until Ctrl-C:
  journal2mcap --end wait

Exports logs starting from now and continues logging until Ctrl-C:
  journal2mcap --start now --end wait

Exports logs between from Jan 1 2023 and Feb 1 2023
  journal2mcap --start $(date -d 2023-01-01 +%s) --end $(date -d 2023-02-01 +%s)

Exports logs between from midnight Jan 1 2023 until the first shutdown after that.
  journal2mcap --start $(date -d 2023-01-01 +%s) --end shutdown

Exports logs from the last boot before midnight Mar 1 2023 until midnight Mar 1 2023.
  journal2mcap --end $(date -d 2023-03-01 +%s)
)";

static const char *SCHEMA_TEXT = R"({
  "title": "foxglove.Log",
  "description": "A log message",
  "$comment": "Generated by https://github.com/foxglove/schemas",
  "type": "object",
  "properties": {
    "timestamp": {
      "type": "object",
      "title": "time",
      "properties": {
        "sec": {
          "type": "integer",
          "minimum": 0
        },
        "nsec": {
          "type": "integer",
          "minimum": 0,
          "maximum": 999999999
        }
      },
      "description": "Timestamp of log message"
    },
    "level": {
      "title": "foxglove.LogLevel",
      "description": "Log level",
      "oneOf": [
        {
          "title": "UNKNOWN",
          "const": 0
        },
        {
          "title": "DEBUG",
          "const": 1
        },
        {
          "title": "INFO",
          "const": 2
        },
        {
          "title": "WARNING",
          "const": 3
        },
        {
          "title": "ERROR",
          "const": 4
        },
        {
          "title": "FATAL",
          "const": 5
        }
      ]
    },
    "message": {
      "type": "string",
      "description": "Log message"
    },
    "name": {
      "type": "string",
      "description": "Process or node name"
    },
    "file": {
      "type": "string",
      "description": "Filename"
    },
    "line": {
      "type": "integer",
      "minimum": 0,
      "description": "Line number in the file"
    }
  }
})";

static std::atomic_bool global_signalled = false;

void on_sigint(int signal) { global_signalled = true; }

std::string get_topic(Transport transport) {
  std::stringstream ss;
  ss << "/journald/";
  ss << name_for_transport(transport);
  return ss.str();
}

int main(int argc, const char **argv) {
  sd_journal *j;
  mcap::McapWriter writer;
  mcap::Message message;
  mcap::Channel channel;
  Options options;
  if (int err = parse_options(argc, argv, &options); err != 0) {
    return err;
  }
  if (options.help) {
    printf("%s\n", DOC);
    return 0;
  }
  if (options.version) {
    printf("%s\n", VERSION);
    return 0;
  }

  if (options.end == TIME_WAIT) {
    signal(SIGINT, on_sigint);
  }
  // open the reader
  int err = sd_journal_open(&j, SD_JOURNAL_LOCAL_ONLY);
  if (err != 0) {
    fprintf(stderr, "failed to open journal: %s\n", strerror(-err));
    return -err;
  }
  // filter by boot ID if neccessary
  err = apply_boot_id_match(j, options);
  if (err != 0) {
    return -err;
  }
  // seek to where recording will start
  err = seek_to_start(j, options.start, options.start_sec);
  if (err != 0) {
    return -err;
  }

  // set up the writer
  auto writerOptions = mcap::McapWriterOptions("");
  const auto res = writer.open(options.output_filename, writerOptions);
  if (!res.ok()) {
    fprintf(stderr, "open failed: %s\n", res.message.c_str());
    return 1;
  }
  // write schema
  mcap::SchemaId schema_id;
  {
    mcap::Schema schema("foxglove.Log", "jsonschema", SCHEMA_TEXT);
    writer.addSchema(schema);
    schema_id = schema.id;
  }

  std::vector<mcap::ChannelId> transport_channel_ids(_TRANSPORT_COUNT, 0);
  std::vector<uint32_t> sequence_counts(_TRANSPORT_COUNT, 0);

  for (size_t i = 0; i < _TRANSPORT_COUNT; ++i) {
    mcap::Channel channel(get_topic((Transport)(i)), "json", schema_id);
    writer.addChannel(channel);
    transport_channel_ids[i] = channel.id;
  }

  while (!global_signalled) {
    int err = next_journal_entry(j, options.end, options.end_sec);
    if (err < 0) {
      fprintf(stderr, "failed to read next entry: %s", strerror(-err));
      writer.close();
      return -err;
    }
    if (err == 0) {
      if (options.end == TIME_WAIT) {
        err = sd_journal_wait(j, 100'000);
        if (err < 0) {
          fprintf(stderr, "failed to wait for more entries: %s",
                  strerror(-err));
          writer.close();
          return -err;
        }
        continue;
      } else {
        break;
      }
    }
    uint64_t ts = 0;
    err = get_ts(j, &ts);
    if (err != 0) {
      fprintf(stderr, "failed to read entry timestamp: %s\n", strerror(-err));
      writer.close();
      return -err;
    }
    message.logTime = ts;
    message.publishTime = ts;
    Transport transport = get_transport(j);
    message.sequence = sequence_counts[transport];
    sequence_counts[transport]++;
    message.channelId = transport_channel_ids[transport];
    std::string json = serialize_json(j, ts);
    message.data = (const std::byte *)(json.c_str());
    message.dataSize = json.size();
    auto res = writer.write(message);
    if (!res.ok()) {
      fprintf(stderr, "failed to write message: %s\n", res.message.c_str());
      writer.close();
      return 1;
    }
  }
  writer.close();
  sd_journal_close(j);

  return 0;
}
